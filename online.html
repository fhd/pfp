<!--
 - This Source Code is subject to the terms of the Mozilla Public License
 - version 2.0 (the "License"). You can obtain a copy of the License at
 - http://mozilla.org/MPL/2.0/.
 -->

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Easy Passwords online password generator</title>
    <link rel="canonical" href="https://palant.github.io/easypasswords/online.html">
    <script>
      "use strict";

      var NUM_ITERATIONS = 256*1024;

      // I, l, O, 0, 1 excluded because of potential confusion. ", ', \ excluded
      // because of common bugs in web interfaces (magic quotes).
      var LOWERCASE = "abcdefghjkmnpqrstuvwxyz";
      var UPPERCASE = "ABCDEFGHJKMNPQRSTUVWXYZ";
      var NUMBER = "23456789";
      var SYMBOL = "!#$%&()*+,-./:;<=>?@[]^_{|}~";

      var DIGEST_LENGTH = 20;
      var BLOCK_SIZE = 64;

      var hasher = (function()
      {
        var heap = new ArrayBuffer(0x10000);
        var maxPaddedChunkLength = BLOCK_SIZE * 2;
        var input = new Int32Array(heap, 0, maxPaddedChunkLength >> 2);
        var state = new Int32Array(heap, maxPaddedChunkLength + 320, 5);
        var hash = RushaCore({Int32Array}, {}, heap).hash;

        /**
         * Initializes the current state, this should be called when the processing
         * starts.
         */
        function initState()
        {
          state[0] = 1732584193;
          state[1] = -271733879;
          state[2] = -1732584194;
          state[3] = 271733878;
          state[4] = -1009589776;
        }

        /**
         * Writes the result of the hash calculation into an array.
         * @param {Uint8Array} outarray
         *   20 bytes array to write the result into
         */
        function getResult(outarray)
        {
          var view = new DataView(outarray.buffer);
          view.setInt32(0, state[0], false);
          view.setInt32(4, state[1], false);
          view.setInt32(8, state[2], false);
          view.setInt32(12, state[3], false);
          view.setInt32(16, state[4], false);
        }

        /**
         * Pads the chunk currently in processing, should be called before
         * processing the last message block.
         * @param {number} chunkLength
         *   length of the current chunk
         * @param {number} messageLength
         *   overall length of the message
         */
        function padData(chunkLength, messageLength)
        {
          var paddedLength = BLOCK_SIZE;
          if (chunkLength + 9 >= BLOCK_SIZE)
            paddedLength = BLOCK_SIZE * 2;

          for (var i = (chunkLength + 3) - (chunkLength + 3) % 4; i < BLOCK_SIZE - 8; i = i + 4)
            input[i >> 2] = 0;
          input[chunkLength >> 2] ^= 0x80 << (24 - (chunkLength % 4 << 3));

          input[paddedLength - 8 >> 2] = messageLength >>> 29;
          input[paddedLength - 4 >> 2] = messageLength << 3;
          return paddedLength;
        }

        /**
         * Takes the state of a previous hashing operation as input data. This
         * function assumes that this will be the last chunk and pads it. It also
         * assumes that there was a block of data preceding it (typical for HMAC).
         */
        function inputFromState(state)
        {
          input[0] = state[0];
          input[1] = state[1];
          input[2] = state[2];
          input[3] = state[3];
          input[4] = state[4];

          var chunkLength = state.length << 2;
          return padData(chunkLength, BLOCK_SIZE + chunkLength);
        }

        /**
         * Takes a typed array as input data.
         * @param {Uint8Array} array
         *   Typed array containing the data
         * @param {number} offset
         *   Offset of the data in the array
         * @param {number} length
         *   Size of the data, cannot be larger than BLOCK_SIZE
         */
        function inputFromArray(array, offset, length)
        {
          var view = new DataView(array.buffer, array.byteOffset + offset, length);
          var pos = 0;
          for (; pos + 3 < length; pos = pos + 4)
            input[pos >> 2] = view.getInt32(pos, false);

          var remaining = length % 4;
          if (remaining)
          {
            input[pos >> 2] = array[offset + pos] << 24 |
                              array[offset + pos + 1] << 16 |
                              array[offset + pos + 2] << 8;
          }
        }

        /**
         * Pre-processes a single block of data and returns the resulting state,
         * allowing to calculate hashes efficiently for different inputs sharing the
         * same first block.
         * @param {Uint8Array} array
         *   Typed array containing the data, must have size BLOCK_SIZE
         * @return {Int32Array}
         *   Copy of the hasher state the operation resulted into
         */
        function preprocessBlock(array)
        {
          initState();
          inputFromArray(array, 0, BLOCK_SIZE);
          hash(BLOCK_SIZE, maxPaddedChunkLength);
          return new Int32Array(hasher.state);
        }

        /**
         * Takes the current hasher state as the input and hashes it on top of a
         * pre-processed block of data represented by the parameter.
         * @param {Int32Array}
         *   Result of a previous preprocessBlock call
         */
        function hashCurrentState(initialState)
        {
          var chunkLength = inputFromState(state);
          state.set(initialState);
          hash(chunkLength, maxPaddedChunkLength);
        }

        /**
         * Hashes an arbitrary-length array with data.
         * @param {Uint8Array} array
         *   Typed array containing the data
         * @param {Int32Array} [initialState]
         *   Result of a previous preprocessBlock call, if omitted the operation
         *   starts with a clean state.
         */
        function hashArray(array, initialState)
        {
          var messageLength = array.length;
          if (initialState)
          {
            messageLength += BLOCK_SIZE;
            hasher.state.set(initialState);
          }
          else
            initState();

          var offset = 0;
          for (; array.length > offset + BLOCK_SIZE; offset = offset + BLOCK_SIZE)
          {
            inputFromArray(array, offset, BLOCK_SIZE);
            hash(BLOCK_SIZE, maxPaddedChunkLength);
          }

          var remaining = array.length - offset;
          inputFromArray(array, offset, remaining);
          hash(padData(remaining, messageLength), maxPaddedChunkLength);
        }

        return {
          state,
          getResult,
          preprocessBlock,
          hashCurrentState,
          hashArray
        };
      })();

      function prepareKey(password)
      {
        // HMAC doesn't use the key directly, it rather zero-pads it to BLOCK_SIZE
        // and xors all bytes with a constant (0x36 for the inner key and 0x5x for
        // the outer one). We can prepare both key variants so that this operation
        // won't need to be repeated - and also feed them to SHA1 already since they
        // will always be the first block of the hashing operation.
        var ikey = new Uint8Array(BLOCK_SIZE);
        if (password.length > BLOCK_SIZE)
        {
          hasher.hashArray(password);
          hasher.getResult(ikey);
        }
        else
          ikey.set(password);

        var okey = Uint8Array.from(ikey);
        for (var i = 0; i < BLOCK_SIZE; i++)
        {
          ikey[i] ^= 0x36;
          okey[i] ^= 0x5c;
        }

        return [hasher.preprocessBlock(ikey), hasher.preprocessBlock(okey)];
      }

      function pbkdf2(password, salt, iterations, length)
      {
        length |= 0;

        var key = prepareKey(password);
        var ikey = key[0];
        var okey = key[1];
        var numChunks = Math.ceil(length / DIGEST_LENGTH);
        var result = new Int32Array(numChunks * DIGEST_LENGTH >>> 2);
        var offset = 0;

        for (var i = 1; i <= numChunks; i++)
        {
          // First iteration works on the and i as 32-bit big-endian number.
          salt[salt.length - 4] = (i >>> 24) & 0xFF;
          salt[salt.length - 3] = (i >>> 16) & 0xFF;
          salt[salt.length - 2] = (i >>> 8) & 0xFF;
          salt[salt.length - 1] = (i >>> 0) & 0xFF;

          // First HMAC operation processes the salt, slightly more complicated
          // because the salt's length is arbitrary.
          hasher.hashArray(salt, ikey);
          hasher.hashCurrentState(okey);
          result.set(hasher.state, offset);

          // Subsequent iterations work on the result of the previous iteration.
          for (var j = 1; j < iterations; j++)
          {
            // Subsequent HMAC operations always operate on the state of the previous
            // operation preceded by the inner/outer key, we can take some shortcuts
            // here.
            hasher.hashCurrentState(ikey);
            hasher.hashCurrentState(okey);
            for (var k = 0; k < hasher.state.length; k++)
              result[offset + k] ^= hasher.state[k];
          }

          offset += DIGEST_LENGTH;
        }

        // Convert result to big-endian
        var view = new DataView(result.buffer);
        for (var i = 0; i < result.length; i++)
          view.setInt32(i << 2, result[i], false);

        return new Uint8Array(result.buffer, 0, length);
      }

      if (typeof exports == "undefined")
      {
        self.onmessage = function({data: {password, salt, iterations, length}})
        {
          self.postMessage(pbkdf2(password, salt, iterations, length).buffer);
        };
      }
      else
      {
        // Allow importing as module, for unit tests.
        exports.pbkdf2 = pbkdf2;
      }

      // The following snippet is taken from rusha 0.8.4:
      // https://github.com/srijs/rusha/blob/v0.8.4/rusha.js#L307

      /* eslint-disable */

      /*
       * Rusha, a JavaScript implementation of the Secure Hash Algorithm, SHA-1,
       * as defined in FIPS PUB 180-1, tuned for high performance with large inputs.
       * (http://github.com/srijs/rusha)
       *
       * Inspired by Paul Johnstons implementation (http://pajhome.org.uk/crypt/md5).
       *
       * Copyright (c) 2013 Sam Rijs (http://awesam.de).
       * Released under the terms of the MIT license as follows:
       *
       * Permission is hereby granted, free of charge, to any person obtaining a
       * copy of this software and associated documentation files (the "Software"),
       * to deal in the Software without restriction, including without limitation
       * the rights to use, copy, modify, merge, publish, distribute, sublicense,
       * and/or sell copies of the Software, and to permit persons to whom the
       * Software is furnished to do so, subject to the following conditions:
       *
       * The above copyright notice and this permission notice shall be included in
       * all copies or substantial portions of the Software.
       *
       * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
       * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
       * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
       * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
       * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
       * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
       * IN THE SOFTWARE.
       */

      function RushaCore(stdlib, foreign, heap) {
          'use asm';
          var H = new stdlib.Int32Array(heap);
          function hash(k, x) {
              // k in bytes
              k = k | 0;
              x = x | 0;
              var i = 0, j = 0, y0 = 0, z0 = 0, y1 = 0, z1 = 0, y2 = 0, z2 = 0, y3 = 0, z3 = 0, y4 = 0, z4 = 0, t0 = 0, t1 = 0;
              y0 = H[x + 320 >> 2] | 0;
              y1 = H[x + 324 >> 2] | 0;
              y2 = H[x + 328 >> 2] | 0;
              y3 = H[x + 332 >> 2] | 0;
              y4 = H[x + 336 >> 2] | 0;
              for (i = 0; (i | 0) < (k | 0); i = i + 64 | 0) {
                  z0 = y0;
                  z1 = y1;
                  z2 = y2;
                  z3 = y3;
                  z4 = y4;
                  for (j = 0; (j | 0) < 64; j = j + 4 | 0) {
                      t1 = H[i + j >> 2] | 0;
                      t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                      y4 = y3;
                      y3 = y2;
                      y2 = y1 << 30 | y1 >>> 2;
                      y1 = y0;
                      y0 = t0;
                      H[k + j >> 2] = t1;
                  }
                  for (j = k + 64 | 0; (j | 0) < (k + 80 | 0); j = j + 4 | 0) {
                      t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                      t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | ~y1 & y3) | 0) + ((t1 + y4 | 0) + 1518500249 | 0) | 0;
                      y4 = y3;
                      y3 = y2;
                      y2 = y1 << 30 | y1 >>> 2;
                      y1 = y0;
                      y0 = t0;
                      H[j >> 2] = t1;
                  }
                  for (j = k + 80 | 0; (j | 0) < (k + 160 | 0); j = j + 4 | 0) {
                      t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                      t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) + 1859775393 | 0) | 0;
                      y4 = y3;
                      y3 = y2;
                      y2 = y1 << 30 | y1 >>> 2;
                      y1 = y0;
                      y0 = t0;
                      H[j >> 2] = t1;
                  }
                  for (j = k + 160 | 0; (j | 0) < (k + 240 | 0); j = j + 4 | 0) {
                      t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                      t0 = ((y0 << 5 | y0 >>> 27) + (y1 & y2 | y1 & y3 | y2 & y3) | 0) + ((t1 + y4 | 0) - 1894007588 | 0) | 0;
                      y4 = y3;
                      y3 = y2;
                      y2 = y1 << 30 | y1 >>> 2;
                      y1 = y0;
                      y0 = t0;
                      H[j >> 2] = t1;
                  }
                  for (j = k + 240 | 0; (j | 0) < (k + 320 | 0); j = j + 4 | 0) {
                      t1 = (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) << 1 | (H[j - 12 >> 2] ^ H[j - 32 >> 2] ^ H[j - 56 >> 2] ^ H[j - 64 >> 2]) >>> 31;
                      t0 = ((y0 << 5 | y0 >>> 27) + (y1 ^ y2 ^ y3) | 0) + ((t1 + y4 | 0) - 899497514 | 0) | 0;
                      y4 = y3;
                      y3 = y2;
                      y2 = y1 << 30 | y1 >>> 2;
                      y1 = y0;
                      y0 = t0;
                      H[j >> 2] = t1;
                  }
                  y0 = y0 + z0 | 0;
                  y1 = y1 + z1 | 0;
                  y2 = y2 + z2 | 0;
                  y3 = y3 + z3 | 0;
                  y4 = y4 + z4 | 0;
              }
              H[x + 320 >> 2] = y0;
              H[x + 324 >> 2] = y1;
              H[x + 328 >> 2] = y2;
              H[x + 332 >> 2] = y3;
              H[x + 336 >> 2] = y4;
          }
          return { hash: hash };
      };

      function derivePassword(params)
      {
        try
        {
          var salt = params.domain + "\0" + params.name;
          if (params.revision)
            salt += "\0" + params.revision;

          var buffer = pbkdf2(
            toUTF8Buffer(params.masterPassword),
            toUTF8Buffer(salt + "    "),
            NUM_ITERATIONS,
            params.length
          );
          var password = toPassword(buffer, params.lower, params.upper, params.number, params.symbol);

          var resultField = $("result");
          resultField.value = password;
          $("result-container").hidden = false;

          // Working around https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9513336/,
          // in Edge we need to make sure the text field is also visible.
          resultField.hidden = true;
          resultField.hidden = false;

          resultField.focus();
          resultField.setSelectionRange(0, resultField.value.length);
        }
        catch (e)
        {
          alert("Error generating password: " + e);
          console.error(e);
        }
      }

      function toPassword(buffer, lower, upper, number, symbol)
      {
        var array = new Uint8Array(buffer);

        var charsets = [];
        if (lower)
          charsets.push(LOWERCASE);
        if (upper)
          charsets.push(UPPERCASE);
        if (number)
          charsets.push(NUMBER);
        if (symbol)
          charsets.push(SYMBOL);

        function lengthSum(previous, current)
        {
          return previous + current.length;
        }

        var numChars = charsets.reduce(lengthSum, 0);
        var seen = Object.create(null);
        var result = [];
        for (var i = 0; i < array.length; i++)
        {
          if (charsets.length - Object.keys(seen).length >= array.length - i)
          {
            for (var value in seen)
            {
              var index = charsets.indexOf(value);
              if (index >= 0)
                charsets.splice(index, 1);
            }
            seen = Object.create(null);
            numChars = charsets.reduce(lengthSum, 0);
          }

          var index = array[i] % numChars;
          for (var j = 0; j < charsets.length; j++)
          {
            var charset = charsets[j];
            if (index < charset.length)
            {
              result.push(charset[index]);
              seen[charset] = true;
              break;
            }
            index -= charset.length;
          }
        }
        return result.join("");
      }

      function toUTF8Buffer(str)
      {
        var matches = encodeURIComponent(str).match(/[^%]|%[0-9a-fA-F]{2}/g) || [];
        var result = new Uint8Array(matches.length);
        for (var i = 0; i < matches.length; i++)
        {
          if (matches[i].length == 1)
            result[i] = matches[i].charCodeAt(0);
          else
            result[i] = parseInt(matches[i].substr(1), 16);
        }
        return result;
      }

      function $(id)
      {
        return document.getElementById(id);
      }

      function updatePasswordLengthDisplay()
      {
        $("password-length-value").textContent = $("password-length").value;
      }

      function generatePassword(event)
      {
        event.preventDefault();

        var revision = $("password-revision").value.trim();
        if (revision == "1")
          revision = "";

        derivePassword({
          masterPassword: $("master-password").value,
          domain: $("site").value,
          name: $("user-name").value,
          revision: revision,
          length: $("password-length").value,
          lower: $("charset-lower").checked,
          upper: $("charset-upper").checked,
          number: $("charset-number").checked,
          symbol: $("charset-symbol").checked
        });
      }

      window.addEventListener("load", function()
      {
        updatePasswordLengthDisplay();
        $("password-length").addEventListener("input", updatePasswordLengthDisplay);
        $("generate-password").addEventListener("submit", generatePassword);

        if (typeof Uint8Array != "function")
        {
          $("general-warning").hidden = true;
          $("unsupported-warning").hidden = false;
        }
      });
    </script>

    <style>
      body
      {
        margin: 0;
        padding: 10px;
        background-color: #fff;
        color: #000;
      }

      body,
      input,
      button
      {
        font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        font-size: 24px;
      }

      input[type="checkbox"]
      {
        width: 24px;
        height: 24px;
      }

      form
      {
        display: flex;
        flex-direction: column;
      }

      form,
      #result-container
      {
        width: 600px;
        margin: auto;
      }

      .warning
      {
        background-color: #faa;
        border-radius: 5px;
        padding: 5px;
        padding-inline-start: 42px;
        -webkit-padding-start: 42px;
        background-image: url(data:image/svg+xml;charset=utf-8,%3C%3Fxml%20version%3D%221.0%22%20encoding%3D%22utf-8%22%3F%3E%0D%0A%3C%21--%20Generator%3A%20Adobe%20Illustrator%2016.2.1%2C%20SVG%20Export%20Plug-In%20.%20SVG%20Version%3A%206.00%20Build%200%29%20%20--%3E%0D%0A%3C%21DOCTYPE%20svg%20PUBLIC%20%22-%2F%2FW3C%2F%2FDTD%20SVG%201.1%2F%2FEN%22%20%22http%3A%2F%2Fwww.w3.org%2FGraphics%2FSVG%2F1.1%2FDTD%2Fsvg11.dtd%22%3E%0D%0A%3Csvg%20version%3D%221.1%22%20id%3D%22Layer_1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20xmlns%3Axlink%3D%22http%3A%2F%2Fwww.w3.org%2F1999%2Fxlink%22%20x%3D%220px%22%20y%3D%220px%22%0D%0A%09%20width%3D%22512px%22%20height%3D%22512px%22%20viewBox%3D%220%200%20512%20512%22%20enable-background%3D%22new%200%200%20512%20512%22%20xml%3Aspace%3D%22preserve%22%3E%0D%0A%3Cg%20id%3D%22Icon_31_%22%3E%0D%0A%09%3Cg%3E%0D%0A%09%09%3Cpath%20d%3D%22M32%2C464h448L256%2C48L32%2C464z%20M280%2C400h-48v-48h48V400z%20M280%2C320h-48v-96h48V320z%22%2F%3E%0D%0A%09%3C%2Fg%3E%0D%0A%3C%2Fg%3E%0D%0A%3C%2Fsvg%3E);
        background-size: 32px;
        background-position: 5px 5px;
        background-repeat: no-repeat;
      }

      form > label,
      .button-container,
      #result-container
      {
        margin-top: 15px;
      }

      #length-container,
      #charsets-container
      {
        display: flex;
        justify-content: space-between;
      }

      #password-length
      {
        flex-grow: 1;
      }

      #password-length-value
      {
        min-width: 3ch;
      }

      .button-container
      {
        display: flex;
        justify-content: center;
      }
    </style>
  </head>
  <body>
    <form id="generate-password" action="#" autocomplete="off">
      <div class="warning" id="unsupported-warning" hidden>
        Your browser doesn't appear to support typed arrays, so this password
        generator won't work. You probably need to update your browser.
      </div>

      <div class="warning" id="general-warning">
        This page will not transmit any data but you have to take my word on it.
        Entering your master password on a webpage is a bad idea, so
        you better use the Easy Passwords extension for
        <a href="https://addons.mozilla.org/addon/easy-passwords/">Firefox</a>,
        <a href="https://chrome.google.com/webstore/detail/hplhaekjfmjfnfdllkpjpeenlbclffgh/">Chrome</a> or <a href="https://addons.opera.com/extensions/details/easy-passwords/">Opera</a>.
        If you need to use this page regularly, it's a good idea to
        <a href="https://github.com/palant/easypasswords/raw/gh-pages/online.html">download it from GitHub</a>
        rather than rely on the hosted version.
      </div>

      <label for="master-password">Master password:</label>
      <input id="master-password" type="password" required>

      <label for="site">Website name:</label>
      <input id="site" type="text" required>

      <label for="user-name">User name:</label>
      <input id="user-name" type="text" required>

      <label for="password-revision">Revision:</label>
      <input id="password-revision" type="text" value="1">

      <label for="password-length">Length:</label>
      <div id="length-container">
        <input id="password-length" type="range" min="4" max="24" step="1" value="16">
        <span id="password-length-value"></span>
      </div>

      <label for="charset-lower">Allowed characters:</label>
      <div id="charsets-container">
        <label><input id="charset-lower" type="checkbox" checked>abc</label>
        <label><input id="charset-upper" type="checkbox" checked>XYZ</label>
        <label><input id="charset-number" type="checkbox" checked>789</label>
        <label><input id="charset-symbol" type="checkbox" checked>+^;</label>
      </div>

      <div class="button-container">
        <button id="generate-password-submit" type="submit">Generate password</button>
      </div>
    </form>

    <div id="result-container" hidden>
      Your generated password is:
      <input id="result" type="text" readonly>
    </div>
  </body>
</html>
